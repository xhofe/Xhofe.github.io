<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Xhofe">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6488351372249466" crossorigin="anonymous"></script>
    
    <title>
        
            Leetcode 2020-03月份每日一题 |
        
        Xhofe&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"nn.ci","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep coding and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Xhofe' Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Xhofe&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives/"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories/"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags/"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links/"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about/"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives/">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories/">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags/">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links/">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about/">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Leetcode 2020-03月份每日一题</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Xhofe</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2020-03-01 17:20:18</span>
        <span class="mobile">2020-03-01 17:20</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/algorithm/">algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/leetcode/">leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>12k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>55 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20-03-leetcode/33ba6a65efb27.png"
                      alt="每日一题" 
                ></p>
<h3 id="1-10"><a class="markdownIt-Anchor" href="#1-10"></a> 1-10</h3>
<h4 id="01-225-用队列实现栈"><a class="markdownIt-Anchor" href="#01-225-用队列实现栈"></a> 01 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/" >225. 用队列实现栈<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h5>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>
<p>push(x) – 元素 x 入栈</p>
</li>
<li>
<p>pop() – 移除栈顶元素</p>
</li>
<li>
<p>top() – 获取栈顶元素</p>
</li>
<li>
<p>empty() – 返回栈是否为空<br />
注意:</p>
</li>
<li>
<p>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</p>
</li>
<li>
<p>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
</li>
<li>
<p>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p>
</li>
</ul>
<h5 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h5>
<p>没啥好说的，就是一个队列存数据，一个队列辅助入栈，入栈时交换两个队列。</p>
<h5 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue1,queue2;</span><br><span class="line">        <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue2=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue1.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue2.isEmpty())queue1.add(queue2.poll());</span><br><span class="line">        Queue tmp=queue1;queue1=queue2;queue2=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-206-反转链表"><a class="markdownIt-Anchor" href="#02-206-反转链表"></a> 02 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/" >206. 反转链表<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h5>
<p>反转一个单链表。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br />
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<p>进阶:<br />
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h5 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h5>
<p>老题目了，上数据结构的时候就说过，遍历链表，遍历到结点链接到上一个节点并记录该结点。</p>
<h5 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode last=<span class="literal">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        ListNode next=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            next=cur.next;</span><br><span class="line">            cur.next=last;</span><br><span class="line">            last=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-面试题-1001-合并排序的数组"><a class="markdownIt-Anchor" href="#03-面试题-1001-合并排序的数组"></a> 03 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sorted-merge-lcci/" >面试题 10.01. 合并排序的数组<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h5>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<p>示例:</p>
<blockquote>
<p>输入:<br />
A = [1,2,3,0,0,0], m = 3<br />
B = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
</blockquote>
<p>说明:</p>
<blockquote>
<p>A.length == n + m</p>
</blockquote>
<h5 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h5>
<p>双指针。</p>
<h5 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> m, <span class="type">int</span>[] B, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=A.length-<span class="number">1</span>;</span><br><span class="line">        m-=<span class="number">1</span>;n-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[m]&gt;B[n])&#123;</span><br><span class="line">                A[i--]=A[m];m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                A[i--]=B[n];n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            A[i--]=B[n];n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="04-994-腐烂的橘子"><a class="markdownIt-Anchor" href="#04-994-腐烂的橘子"></a> 04 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotting-oranges/" >994. 腐烂的橘子<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h5>
<p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格；</li>
<li>值 1 代表新鲜橘子；</li>
<li>值 2 代表腐烂的橘子。</li>
<li>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</li>
</ul>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<p><strong>示例 1：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20-03-leetcode/oranges.png"
                      alt="" 
                ></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ol>
<h5 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h5>
<p>模拟一遍这个过程，但是每次烂掉的橘子记为-1，之后再统一标记为2，避免一次中的腐烂传播。</p>
<h5 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lan(grid))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">lan</span><span class="params">(<span class="type">int</span> [][] grid)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> lan=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=grid.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i-<span class="number">1</span>][j]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;grid.length&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i+<span class="number">1</span>][j]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i][j-<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;grid[<span class="number">0</span>].length&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i][j+<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=grid.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==-<span class="number">1</span>)&#123;</span><br><span class="line">                    grid[i][j]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="05-1103-分糖果-ii"><a class="markdownIt-Anchor" href="#05-1103-分糖果-ii"></a> 05 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-candies-to-people/" >1103. 分糖果 II<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h5>
<p>排排坐，分糖果。</p>
<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <code>n = num_people</code>个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第<code>i</code> 个小朋友分到的糖果数）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = 7, num_people = 4</span><br><span class="line">输出：[1,2,3,1]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] += 1，数组变为 [1,0,0,0]。</span><br><span class="line">第二次，ans[1] += 2，数组变为 [1,2,0,0]。</span><br><span class="line">第三次，ans[2] += 3，数组变为 [1,2,3,0]。</span><br><span class="line">第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = 10, num_people = 3</span><br><span class="line">输出：[5,2,3]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] += 1，数组变为 [1,0,0]。</span><br><span class="line">第二次，ans[1] += 2，数组变为 [1,2,0]。</span><br><span class="line">第三次，ans[2] += 3，数组变为 [1,2,3]。</span><br><span class="line">第四次，ans[0] += 4，最终数组变为 [5,2,3]。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= candies &lt;= 10^9</code></li>
<li><code>1 &lt;= num_people &lt;= 1000</code></li>
</ul>
<h5 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h5>
<p>纯数学计算，先计算出把所有小朋友发全可以发多少次，然后剩下的糖果模拟发完为止。</p>
<h5 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] distributeCandies(<span class="type">int</span> candies, <span class="type">int</span> num_people) &#123;</span><br><span class="line">        <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[num_people];</span><br><span class="line">        <span class="type">int</span> tmp=candies;</span><br><span class="line">        <span class="type">int</span> count=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            candies=tmp;++count;</span><br><span class="line">            tmp-=num_people*((<span class="number">2</span>*count+<span class="number">1</span>)*num_people+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num_people; i++) &#123;</span><br><span class="line">            res[i]=count*(<span class="number">2</span>*(i+<span class="number">1</span>)+(count-<span class="number">1</span>)*num_people)/<span class="number">2</span>;</span><br><span class="line">            tmp=count*num_people+i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (candies&lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (candies&gt;=tmp)&#123;</span><br><span class="line">                res[i]+=tmp;</span><br><span class="line">                candies-=tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[i]+=candies;</span><br><span class="line">                candies=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="06-面试题57-ii-和为s的连续正数序列"><a class="markdownIt-Anchor" href="#06-面试题57-ii-和为s的连续正数序列"></a> 06 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" >面试题57 - II. 和为s的连续正数序列<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h5>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：target = 9<br />
输出：[[2,3,4],[4,5]]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：target = 15<br />
输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
</blockquote>
<p>限制：</p>
<ul>
<li>1 &lt;= target &lt;= 10^5</li>
</ul>
<h5 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h5>
<p>滑动窗口，因为都是正数，要往目标和靠近，小的时候右边界右移，大的时候左边界右移。</p>
<h5 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> code</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContinuousSequence</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        i = <span class="number">1</span>  <span class="comment"># 滑动窗口的左边界</span></span><br><span class="line">        j = <span class="number">1</span>  <span class="comment"># 滑动窗口的右边界</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span>  <span class="comment"># 滑动窗口中数字的和</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt;= target // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                <span class="built_in">sum</span> += j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                <span class="built_in">sum</span> -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr = <span class="built_in">list</span>(<span class="built_in">range</span>(i, j))</span><br><span class="line">                res.append(arr)</span><br><span class="line">                <span class="built_in">sum</span> -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="07-面试题59-ii-队列的最大值"><a class="markdownIt-Anchor" href="#07-面试题59-ii-队列的最大值"></a> 07 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" >面试题59 - II. 队列的最大值<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h5>
<p>请定义一个队列并实现函数<code>max_value</code>得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code>的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code>和 <code>max_value</code>需要返回 -1</p>
<p>示例 1：</p>
<blockquote>
<p><strong>输入</strong>:<br />
[&quot;<code>MaxQueue</code>&quot;,“push_back”,“push_back”,“max_value”,“pop_front”,“max_value”]<br />
[[],[1],[2],[],[],[]]<br />
<strong>输出</strong>: [null,null,null,2,1,2]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p><strong>输入</strong>:<br />
[&quot;<code>MaxQueue</code>&quot;,“pop_front”,“max_value”]<br />
[[],[],[]]<br />
<strong>输出</strong>: [null,-1,-1]</p>
</blockquote>
<p>限制：</p>
<ul>
<li>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</li>
<li>1 &lt;= value &lt;= 10^5</li>
</ul>
<h5 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h5>
<p>当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。所以我们只需要维护一个单调队列即可，在放入元素的时候，将单调队列里所有比该元素小的值<code>poll</code>，输出元素的时候，如果这个元素是当时的最大值，则将单调队列也进行<code>poll</code>。</p>
<h5 id="code-7"><a class="markdownIt-Anchor" href="#code-7"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">        <span class="keyword">private</span> Deque&lt;Integer&gt; max;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">            queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            max=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (max.isEmpty())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> max.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            queue.add(value);</span><br><span class="line">            <span class="keyword">while</span> (!max.isEmpty()&amp;&amp;max.getLast()&lt;value)max.pollLast();</span><br><span class="line">            max.add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> value=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (max.getFirst()==value)max.pollFirst();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="08-322-零钱兑换"><a class="markdownIt-Anchor" href="#08-322-零钱兑换"></a> 08 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/" >322. 零钱兑换<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h5>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:<br />
你可以认为每种硬币的数量是无限的。</p>
<h5 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h5>
<p>动态规划，属于背包问题。<code>dp[i][j]</code>记录当只用前i种硬币组合j时的最少硬币个数，则有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=\min(dp[i-1][j],dp[i][j-coins[i]]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.如果<code>dp[i][j-coins[i]]</code>存在的话。因为只使用了上一次的状态，所以可以用滚动数组进行优化。</p>
<h5 id="code-8"><a class="markdownIt-Anchor" href="#code-8"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=coins.length;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i]=Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=coins[i];j&lt;amount+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[j]=Integer.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount]&gt;=amount+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="09-121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#09-121-买卖股票的最佳时机"></a> 09 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" >121. 买卖股票的最佳时机<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h5>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br />
输出: 5<br />
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br />
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br />
输出: 0<br />
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<h5 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h5>
<p>从前往后遍历，记录当前最小值与当前值减去最小值的差的最大值。</p>
<h5 id="code-9"><a class="markdownIt-Anchor" href="#code-9"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            min=Math.min(min,price);</span><br><span class="line">            res=Math.max(res,price-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-543-二叉树的直径"><a class="markdownIt-Anchor" href="#10-543-二叉树的直径"></a> 10 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" >543. 二叉树的直径<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h5>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例</strong> :<br />
给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre>
<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<h5 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h5>
<p>递归，其实最大直径就是左子树的深度+右子树的深度。</p>
<h5 id="code-10"><a class="markdownIt-Anchor" href="#code-10"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        deep(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deep</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=deep(node.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right=deep(node.right)+<span class="number">1</span>;</span><br><span class="line">        res=Math.max(res,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-20"><a class="markdownIt-Anchor" href="#11-20"></a> 11-20</h3>
<h4 id="11-1013-将数组分成和相等的三个部分"><a class="markdownIt-Anchor" href="#11-1013-将数组分成和相等的三个部分"></a> 11 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" >1013. 将数组分成和相等的三个部分<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h5>
<p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p>
<p>形式上，如果可以找出索引<code>i+1 &lt; j</code>且满足 <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code>就可以将数组三等分。</p>
<p><strong>示例 1</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure>
<h5 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h5>
<p>先计算出总和，看能不能被3整除，然后模拟一下即可。</p>
<h5 id="code-11"><a class="markdownIt-Anchor" href="#code-11"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canThreePartsEqualSum</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: A) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            curSum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">cnt</span> <span class="operator">=</span>= <span class="number">3</span> || (cnt &gt; <span class="number">3</span> &amp;&amp; sum == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-1071-字符串的最大公因子"><a class="markdownIt-Anchor" href="#12-1071-字符串的最大公因子"></a> 12 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" >1071. 字符串的最大公因子<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h5>
<p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p>
<p>返回最长字符串 X，要求满足 X 能除尽<code>str1</code>且 X 能除尽<code>str2</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;</span><br><span class="line">输出：&quot;ABC&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;</span><br><span class="line">输出：&quot;AB&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;</span><br><span class="line">输出：&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= str1.length &lt;= 1000</code></li>
<li><code>1 &lt;= str2.length &lt;= 1000</code></li>
<li><code>str1[i]</code>和<code>str2[i]</code>为大写英文字母</li>
</ul>
<h5 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h5>
<p>如果两个字符串有公因子串，则必有<code>str1+str2=str2+str1</code>，用辗转相除法计算出长度的最大公因数，截取其中一段即为最大公因子串了。</p>
<h5 id="code-12"><a class="markdownIt-Anchor" href="#code-12"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">gcdOfStrings</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str1+str2).equals(str2+str1))<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,gcd(str1.length(),str2.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-169-多数元素"><a class="markdownIt-Anchor" href="#13-169-多数元素"></a> 13 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/" >169. 多数元素<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h5>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h5 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h5>
<p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，因为最多的数出现的次数大于一半，所以最后总会找到这个数。</p>
<h5 id="code-13"><a class="markdownIt-Anchor" href="#code-13"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> cur=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num==cur)count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">                cur=num;</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-300-最长上升子序列"><a class="markdownIt-Anchor" href="#14-300-最长上升子序列"></a> 14 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" >300. 最长上升子序列<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h5>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<blockquote>
<p>输入: [10,9,2,5,3,7,101,18]<br />
输出: 4<br />
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
</blockquote>
<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br />
你算法的时间复杂度应该为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p>
<h5 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h5>
<p>常规<code>dp</code>就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里参考官方题解的贪心+二分。</p>
<blockquote>
<p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
<p>基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 ii 的最长上升子序列的末尾元素的最小值，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> 记录目前最长上升子序列的长度，起始时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> 为 11，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[1]=nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>。</p>
<p>同时我们可以注意到 d[i]d[i] 是关于 ii 单调递增的。因为如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[j] \geq d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且$ j &lt; i$，我们考虑从长度为 ii 的最长上升子序列的末尾删除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个元素，那么这个序列长度变为 j，且第 j个元素 xx（末尾元素）必然小于 d[i]，也就小于 d[j]。那么我们就找到了一个长度为 j的最长上升子序列，并且末尾元素比 d[j] 小，从而产生了矛盾。因此数组 d[] 的单调性得证。</p>
<p>我们依次遍历数组 $nums[] $中的每个元素，并更新数组 d[]d[] 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> 的值。如果$ \textit{nums}[i] &gt; d[\textit{len}] $则更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">len = len + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，否则在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mn>1</mn><mo>…</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[1 \ldots len]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>中找满足$ d[i−1]&lt;nums[j]&lt;d[i] $的下标 ii，并更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[i]=nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>。</p>
<p>根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>
<p>最后整个算法流程为：</p>
<p>设当前已求出的最长上升子序列的长度为$ len$（初始时为 11），从前往后遍历数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，在遍历到 $nums[i] $时：</p>
<p>如果$nums[i]&gt;d[len] $，则直接加入到 d 数组末尾，并更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">len=len+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p>
<p>否则，在 d 数组中二分查找，找到第一个比$nums[i] $小的数 d[k] ，并更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[k+1]=nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。</p>
<p>作者：<code>LeetCode-Solution</code><br />
链接：<a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/" >https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h5 id="code-14"><a class="markdownIt-Anchor" href="#code-14"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = (<span class="type">int</span>)nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] d=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-695-岛屿的最大面积"><a class="markdownIt-Anchor" href="#15-695-岛屿的最大面积"></a> 15 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/" >695. 岛屿的最大面积<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h5>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为 0 。)</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure>
<p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure>
<p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p>
<h5 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h5>
<p>对于每个1进行<code>dfs</code>。下面的代码其实可以不必使用cur标记是否访问，直接对访问过进行置0即可。</p>
<h5 id="code-15"><a class="markdownIt-Anchor" href="#code-15"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][]conditions=&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] cur;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur=<span class="keyword">new</span> <span class="title class_">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="type">int</span> cur_res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>&amp;&amp;!cur[i][j])&#123;</span><br><span class="line">                    cur_res=maxAreaOfIsland(grid,i,j);</span><br><span class="line">                    res=Math.max(res,cur_res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> cur_res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i==grid.length||j&lt;<span class="number">0</span>||j==grid[<span class="number">0</span>].length||cur[i][j]||grid[i][j]!=<span class="number">1</span>)<span class="keyword">return</span> cur_res;</span><br><span class="line">        cur_res++;</span><br><span class="line">        cur[i][j]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            cur_res+=maxAreaOfIsland(grid,i+conditions[k][<span class="number">0</span>],j+conditions[k][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-面试题-0106-字符串压缩"><a class="markdownIt-Anchor" href="#16-面试题-0106-字符串压缩"></a> 16 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/compress-string-lcci/" >面试题 01.06. 字符串压缩<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h5>
<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">输出：&quot;a2b1c5a3&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbccd&quot;</span><br><span class="line">输出：&quot;abbccd&quot;</span><br><span class="line">解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>字符串长度在[0, 50000]范围内。</li>
</ul>
<h5 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h5>
<p>直接模拟这个过程即可。</p>
<h5 id="code-16"><a class="markdownIt-Anchor" href="#code-16"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">compressString</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.length()&lt;<span class="number">3</span>)<span class="keyword">return</span> S;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span> c=S.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i)==c)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c).append(count);</span><br><span class="line">                <span class="keyword">if</span> (sb.length()&gt;=S.length())&#123;</span><br><span class="line">                    <span class="keyword">return</span> S;</span><br><span class="line">                &#125;</span><br><span class="line">                c=S.charAt(i);</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(c).append(count);</span><br><span class="line">        <span class="keyword">if</span> (sb.length()&gt;=S.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17-1160-拼写单词"><a class="markdownIt-Anchor" href="#17-1160-拼写单词"></a> 17 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" >1160. 拼写单词<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h5>
<p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p>
<p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</p>
<p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
<li>所有字符串中都仅包含小写英文字母</li>
</ul>
<h5 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h5>
<p>只有26个字母，直接数组哈希。逐个测试即可。</p>
<h5 id="code-17"><a class="markdownIt-Anchor" href="#code-17"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCharacters</span><span class="params">(String[] words, String chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : chars.toCharArray())&#123;</span><br><span class="line">            hash[ch - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            Arrays.fill(map, <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> ch : word.toCharArray())&#123;</span><br><span class="line">                map[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(map[ch - <span class="string">&#x27;a&#x27;</span>] &gt; hash[ch - <span class="string">&#x27;a&#x27;</span>]) flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len += flag ? word.length() : <span class="number">0</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-836-矩形重叠"><a class="markdownIt-Anchor" href="#18-836-矩形重叠"></a> 18 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rectangle-overlap/" >836. 矩形重叠<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h5>
<p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</li>
<li>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</li>
<li>x 轴默认指向右，y 轴默认指向上。</li>
<li>你可以仅考虑矩形是正放的情况。</li>
</ul>
<h5 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rectangle-overlap/comments/292063" >思路<i class="fas fa-external-link-alt"></i></a></h5>
<p>矩形如果不重叠，从x轴和y轴上看两个矩形就变成了两条线段，这两条线段肯定是不相交的，也就是说左边的矩形的最右边小于右边矩形的最左边，也就是<code>rec1[2] &lt; rec2[0] || rec2[2] &lt; rec1[0]</code>；y轴同理，下面的矩形的最上边小于上面矩形的最下边，也就是<code>rec1[3] &lt; rec2[1] || rec2[3] &lt; rec1[1]</code>。因为题目要求重叠算相离，所以加上<code>=</code>，最后取反就行啦~</p>
<h5 id="code-18"><a class="markdownIt-Anchor" href="#code-18"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleOverlap</span><span class="params">(<span class="type">int</span>[] rec1, <span class="type">int</span>[] rec2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] || rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>] || rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] || rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-409-最长回文串"><a class="markdownIt-Anchor" href="#19-409-最长回文串"></a> 19 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome/" >409. 最长回文串<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h5>
<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>
<p><strong>注意:</strong><br />
假设字符串的长度不会超过 1010。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>
<h5 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h5>
<p>直接统计每个字符的个数。只要是复数出现的即可，最后还可以加上一个正中间的。</p>
<h5 id="code-19"><a class="markdownIt-Anchor" href="#code-19"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">58</span>];</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">             cnts[s.charAt(i) - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">int</span> <span class="variable">palindrome</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> cnt : cnts) &#123;</span><br><span class="line">             palindrome += (cnt / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (palindrome &lt; s.length()) &#123;</span><br><span class="line">             palindrome++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> palindrome;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20-面试题40-最小的k个数"><a class="markdownIt-Anchor" href="#20-面试题40-最小的k个数"></a> 20 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" >面试题40. 最小的k个数<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h5>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<h5 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h5>
<p>二分法，每次取mid，将数组分为两个部分，如果小的那部分&gt;k，则继续再这部分进行二分，如果&lt;k，则这些数都是结果，再在大的部分继续取剩下的数，如果刚好等于要取的数，则结束。</p>
<h5 id="code-20"><a class="markdownIt-Anchor" href="#code-20"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> len=arr.length;</span><br><span class="line">        <span class="type">int</span> leftL,rightL;</span><br><span class="line">        <span class="type">int</span>[] left=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] right=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="type">int</span>[] midA=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> midL;</span><br><span class="line">        <span class="keyword">while</span> (index&lt;k)&#123;</span><br><span class="line">            leftL=<span class="number">0</span>;rightL=<span class="number">0</span>;midL=<span class="number">0</span>;</span><br><span class="line">            mid=arr[len/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]&lt;mid)&#123;</span><br><span class="line">                    left[leftL++]=arr[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]==mid)midA[midL++]=arr[i];</span><br><span class="line">                <span class="keyword">else</span> right[rightL++]=arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftL&gt;(k-index))&#123;</span><br><span class="line">                arr=left;</span><br><span class="line">                len=leftL;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leftL; i++) &#123;</span><br><span class="line">                    res[index++]=left[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (index&lt;k&amp;&amp;tmp&lt;midL)&#123;</span><br><span class="line">                    res[index++]=midA[tmp++];</span><br><span class="line">                &#125;</span><br><span class="line">                arr=right;</span><br><span class="line">                len=rightL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-31"><a class="markdownIt-Anchor" href="#21-31"></a> 21-31</h3>
<h4 id="21-365-水壶问题"><a class="markdownIt-Anchor" href="#21-365-水壶问题"></a> 21 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/water-and-jug-problem/" >365. 水壶问题<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h5>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=BVtQNK_ZUJg"><em>“Die Hard”</em> example</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h5 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/" >思路<i class="fas fa-external-link-alt"></i></a></h5>
<blockquote>
<p>预备知识：贝祖定理</p>
<p>我们认为，每次操作只会让桶里的水总量增加 x，增加 y，减少 x，或者减少 y。</p>
<p>你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是 x 或者 y 了吗？接下来我们来解释这一点：</p>
<p>首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的；</p>
<p>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；</p>
<p>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</p>
<p>因此，我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a,b，使得</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">ax+by=z
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></span></p>
<p>而只要满足z≤x+y，且这样的 a,b 存在，那么我们的目标就是可以达成的。这是因为：</p>
<ul>
<li>
<p>若a≥0,b≥0，那么显然可以达成目标。</p>
</li>
<li>
<p>若a&lt;0，那么可以进行以下操作：</p>
<ol>
<li>
<p>往 y 壶倒水；</p>
</li>
<li>
<p>把 y 壶的水倒入 x 壶；</p>
</li>
<li>
<p>如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。</p>
</li>
</ol>
<p>重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。</p>
</li>
<li>
<p>若 b&lt;0，方法同上，x 与 y 互换。</p>
</li>
</ul>
<p>而贝祖定理告诉我们，ax+by=z 有解当且仅当 z 是 x,y 的最大公约数的倍数。因此我们只需要找到x,y 的最大公约数并判断 z 是否是它的倍数即可。</p>
</blockquote>
<h5 id="code-21"><a class="markdownIt-Anchor" href="#code-21"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMeasureWater</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (x+y&lt;z)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (x+y==z||x==z||y==z||x==<span class="number">1</span>||y==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (x==y||x==<span class="number">0</span>||y==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> gcd=getGCD(x,y);</span><br><span class="line">        <span class="keyword">if</span> (gcd==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> gcd&lt;z&amp;&amp;z%gcd==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 数学上不考虑负数的约数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a % b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-945-使数组唯一的最小增量"><a class="markdownIt-Anchor" href="#22-945-使数组唯一的最小增量"></a> 22 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" >945. 使数组唯一的最小增量<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h5>
<p>给定整数数组 A，每次 <em>move</em> 操作将会选择任意 <code>A[i]</code>，并将其递增 <code>1</code>。</p>
<p>返回使 <code>A</code> 中的每个值都是唯一的最少操作次数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt; 40000</code></li>
</ol>
<h5 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h5>
<p>首先模拟也可以做，但是很慢，所以可以利用空间换时间的方法，记录下所有的数出现的次数，遍历这些数，对于每个数出现次数&gt;1的数进行次数-1的move操作，所以该数+1要的次数要加上该数的次数-1，结果加上move的次数即可。</p>
<h5 id="code-22"><a class="markdownIt-Anchor" href="#code-22"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIncrementForUnique</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="comment">// Arrays.sort(A);</span></span><br><span class="line">        <span class="comment">// int res=0;</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt; A.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     while (A[i]&lt;=A[i-1])&#123;</span></span><br><span class="line">        <span class="comment">//         A[i]++;</span></span><br><span class="line">        <span class="comment">//         res++;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="comment">//空间换时间</span></span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">50000</span>];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:A)&#123;</span><br><span class="line">            arr[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                arr[i+<span class="number">1</span>]+=arr[i]-<span class="number">1</span>;</span><br><span class="line">                res+=arr[i]-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="23-876-链表的中间结点"><a class="markdownIt-Anchor" href="#23-876-链表的中间结点"></a> 23 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" >876. 链表的中间结点<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h5>
<p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li>
</ul>
<h5 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h5>
<p>经典的快慢指针用法。</p>
<h5 id="code-23"><a class="markdownIt-Anchor" href="#code-23"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24-面试题-1716-按摩师"><a class="markdownIt-Anchor" href="#24-面试题-1716-按摩师"></a> 24 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-masseuse-lcci/" >面试题 17.16. 按摩师<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h5>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</span><br></pre></td></tr></table></figure>
<h5 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h5>
<p>动态规划：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i]=\max(dp[i-1],dp[i-2]+nums[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>
<h5 id="code-24"><a class="markdownIt-Anchor" href="#code-24"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">massage</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]= Math.max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="25-892-三维形体的表面积"><a class="markdownIt-Anchor" href="#25-892-三维形体的表面积"></a> 25 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" >892. 三维形体的表面积<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h5>
<p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code> 的立方体。</p>
<p>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p>
<p>请你返回最终形体的表面积。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ul>
<h5 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h5>
<p>对于每个格子里的正方体，首先是上下两个面，然后是每个有四个侧面，最后减去重复计算的侧面即可。</p>
<h5 id="code-25"><a class="markdownIt-Anchor" href="#code-25"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">surfaceArea</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    res+=<span class="number">2</span>;</span><br><span class="line">                    res+=grid[i][j]&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">0</span>)res-=Math.min(grid[i][j],grid[i-<span class="number">1</span>][j])&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j&gt;<span class="number">0</span>)res-=Math.min(grid[i][j],grid[i][j-<span class="number">1</span>])&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// if (i&lt;grid.length-1)res-=Math.min(grid[i][j],grid[i+1][j]);</span></span><br><span class="line">                    <span class="comment">// if (j&lt;grid[0].length-1)res-=Math.min(grid[i][j],grid[i][j+1]);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="26-999-可以被一步捕获的棋子数"><a class="markdownIt-Anchor" href="#26-999-可以被一步捕获的棋子数"></a> 26 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/available-captures-for-rook/" >999. 可以被一步捕获的棋子数<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h5>
<p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>'R'</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>'.'</code>，<code>'B'</code> 和 <code>'p'</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。</p>
<p>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p>
<ul>
<li>棋手选择主动停下来。</li>
<li>棋子因到达棋盘的边缘而停下。</li>
<li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li>
<li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li>
</ul>
<p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p>
<p><strong>示例 1：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20-03-leetcode/1253_example_1_improved.PNG"
                      style="zoom:50%;" 
                >
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li><code>board.length == board[i].length == 8</code></li>
<li><code>board[i][j]</code>可以是<code>'R'，'.'，'B'</code>或 <code>'p'</code></li>
<li>只有一个格子上存在<code>board[i][j] == 'R'</code></li>
</ol>
<h5 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h5>
<p>很没意思的一道题。。。。</p>
<h5 id="code-26"><a class="markdownIt-Anchor" href="#code-26"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRookCaptures</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                    row=i;col=j;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp=row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">char</span> c=board[tmp][col];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;B&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;p&#x27;</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=row+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&lt;board.length)&#123;</span><br><span class="line">            <span class="type">char</span> c=board[tmp][col];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;B&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;p&#x27;</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">char</span> c=board[row][tmp];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;B&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;p&#x27;</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=col+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&lt;board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="type">char</span> c=board[row][tmp];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;B&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;p&#x27;</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="27-914-卡牌分组"><a class="markdownIt-Anchor" href="#27-914-卡牌分组"></a> 27 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" >914. 卡牌分组<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h5>
<p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 <code>X</code> 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= deck.length &lt;= 10000</code></li>
<li><code>0 &lt;= deck[i] &lt; 10000</code></li>
</ol>
<h5 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h5>
<p>先给这些牌排个序。</p>
<p>然后记录所有牌的张数。以及最少的张数。</p>
<p>然后从2…最少的张数进行测试可否分组。</p>
<p>下面的代码写成hash会更好一点，懒得写了。。</p>
<h5 id="code-27"><a class="markdownIt-Anchor" href="#code-27"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasGroupsSizeX</span><span class="params">(<span class="type">int</span>[] deck)</span> &#123;</span><br><span class="line">        Arrays.sort(deck);</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; deck.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deck[i]==deck[i-<span class="number">1</span>])tmp++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                min=Math.min(min,tmp);</span><br><span class="line">                list.add(tmp);</span><br><span class="line">                tmp=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        min=Math.min(min,tmp);</span><br><span class="line">        list.add(tmp);</span><br><span class="line">        tmp=min;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= min; i++) &#123;</span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (min%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer ii:list)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (ii % i != <span class="number">0</span>) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="28-820-单词的压缩编码"><a class="markdownIt-Anchor" href="#28-820-单词的压缩编码"></a> 28 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/short-encoding-of-words/" >820. 单词的压缩编码<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h5>
<p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。</p>
<p>例如，如果这个列表是 <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>，我们就可以将其表示为 <code>S = &quot;time#bell#&quot;</code> 和 <code>indexes = [0, 2, 5]</code>。</p>
<p>对于每一个索引，我们可以通过从字符串 <code>S</code> 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
<li>每个单词都是小写字母 。</li>
</ol>
<h5 id="思路-28"><a class="markdownIt-Anchor" href="#思路-28"></a> 思路</h5>
<p>很烂的思路，先对单词进行按长度排序。然后遍历判断是否以其他单词结尾的，如果有单词被别的单词包含就不计算，最后的结果就是没有被包含的单词的长度+1的和。</p>
<p>最好的做法是用字典树（前缀树），奈何不会~待学。。</p>
<p>这道题将字符串倒过来就是判断前缀是否包含单词了。</p>
<h5 id="code-28"><a class="markdownIt-Anchor" href="#code-28"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLengthEncoding</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        Arrays.sort(words,(a,b)-&gt;(Integer.compare(b.length(), a.length())));</span><br><span class="line">        <span class="type">boolean</span>[] flags=<span class="keyword">new</span> <span class="title class_">boolean</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            String tmp=words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flags[j]&amp;&amp;tmp.endsWith(words[j]))&#123;</span><br><span class="line">                    flags[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flags[i])res+=words[i].length()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/" >字典树做法<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLengthEncoding</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="comment">// 先对单词列表根据单词长度由长到短排序</span></span><br><span class="line">        Arrays.sort(words, (s1, s2) -&gt; s2.length() - s1.length());</span><br><span class="line">        <span class="comment">// 单词插入trie，返回该单词增加的编码长度</span></span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            len += trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义tire</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    </span><br><span class="line">    TrieNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 倒着插入单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> word.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[c] == <span class="literal">null</span>) &#123;</span><br><span class="line">                isNew = <span class="literal">true</span>; <span class="comment">// 是新单词</span></span><br><span class="line">                cur.children[c] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是新单词的话编码长度增加新单词的长度+1，否则不变。</span></span><br><span class="line">        <span class="keyword">return</span> isNew? word.length() + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="29-1162-地图分析"><a class="markdownIt-Anchor" href="#29-1162-地图分析"></a> 29 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" >1162. 地图分析<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h5>
<p>你现在手里有一份大小为 N x N 的「地图」（网格） <code>grid</code>，上面的每个「区域」（单元格）都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个区域之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20-03-leetcode/1336_ex1.jpeg"
                      alt="" 
                ></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20-03-leetcode/1336_ex2.jpeg"
                      alt="" 
                ></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0,0],[0,0,0],[0,0,0]]</span><br><span class="line">输出：4</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ol>
<h5 id="思路-29"><a class="markdownIt-Anchor" href="#思路-29"></a> 思路</h5>
<p>先找出所有的陆地，再从陆地开始进行分层的<code>BFS</code>，遍历的最大深度即为解。</p>
<h5 id="code-29"><a class="markdownIt-Anchor" href="#code-29"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][]conditions=&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        <span class="type">int</span> N=grid.length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.size()==N*N||queue.size()==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="type">int</span> tmp=queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; tmp; k++) &#123;</span><br><span class="line">                <span class="type">int</span>[] poi=queue.poll();</span><br><span class="line">                <span class="type">int</span> i=poi[<span class="number">0</span>],j=poi[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line">                    <span class="type">int</span> newi=i+conditions[l][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> newj=j+conditions[l][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newi&lt;<span class="number">0</span>||newj&lt;<span class="number">0</span>||newi==N||newj==N)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[newi][newj]==<span class="number">0</span>)&#123;</span><br><span class="line">                        grid[newi][newj]=-<span class="number">1</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newi,newj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="30-面试题62-圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#30-面试题62-圆圈中最后剩下的数字"></a> 30 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" >面试题62. 圆圈中最后剩下的数字<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-30"><a class="markdownIt-Anchor" href="#题目-30"></a> 题目</h5>
<p>0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<h5 id="思路-30"><a class="markdownIt-Anchor" href="#思路-30"></a> 思路</h5>
<p>首先是模拟这个过程，但是会超时，官方给出<a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/si-chong-fang-fa-xiang-xi-jie-da-by-yuanninesuns/" >数学法<i class="fas fa-external-link-alt"></i></a>：</p>
<blockquote>
<p>【思路】</p>
<p>n个数字的圆圈，不断删除第m个数字，我们把最后剩下的数字记为f(n,m)<br />
n个数字中第一个被删除的数字是(m-1)%n (取余的原因是m可能比n大)， 我们记作k，k=(m-1)%n<br />
那么剩下的n-1个数字就变成了：0,1,……k-1,k+1,……,n-1，我们把下一轮第一个数字排在最前面，并且将这个长度为n-1的数组映射到0~n-2。</p>
<table>
<thead>
<tr>
<th>原始数组</th>
<th>映射数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>k+1</td>
<td>0</td>
</tr>
<tr>
<td>k+2</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n-1</td>
<td>n-k-2</td>
</tr>
<tr>
<td>0</td>
<td>n-k-1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>k-1</td>
<td>n-2</td>
</tr>
</tbody>
</table>
<p>把映射数字记为x，原始数字记为y，那么映射数字变回原始数字的公式为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">y=(x+k+1)\mod n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>在映射数字中，n-1个数字，不断删除第m个数字，由定义可以知道，最后剩下的数字为f(n-1,m)。我们把它变回原始数字，由上一个公式可以得到最后剩下的原始数字是（f(n-1,m)+k+1)%n，而这个数字也就是一开始我们标记的f(n,m)，所以可以推得递归公式为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">f(n,m) =(f(n-1,m)+k+1)\mod n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>将k=(m-1)%n代入，化简得到：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">且</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n,m) =(f(n-1,m)+m)\mod n， 且f(1,m) = 0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">且</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>代码中可以采用迭代或者递归的方法实现该递归公式。时间复杂度为O(n)，空间复杂度为O(1)<br />
注意公式中的mod就等同于%，为取模运算。值得注意的是，在数学中，下式成立：(a%n+b)%n=(a+b)%n</p>
</blockquote>
<h5 id="code-30"><a class="markdownIt-Anchor" href="#code-30"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟法</span></span><br><span class="line">        <span class="comment">// boolean[] flag=new boolean[n];</span></span><br><span class="line">        <span class="comment">// int index=-1;</span></span><br><span class="line">        <span class="comment">// int tmp;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n-1; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     tmp=m;</span></span><br><span class="line">        <span class="comment">//     while (tmp!=0)&#123;</span></span><br><span class="line">        <span class="comment">//         if (++index==n)index=0;</span></span><br><span class="line">        <span class="comment">//         if (!flag[index])&#123;</span></span><br><span class="line">        <span class="comment">//             --tmp;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     flag[index]=true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (!flag[i])return i;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return 0;</span></span><br><span class="line">        <span class="comment">// 数学法tql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="31-912-排序数组"><a class="markdownIt-Anchor" href="#31-912-排序数组"></a> 31 <a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/" >912. 排序数组<i class="fas fa-external-link-alt"></i></a></h4>
<h5 id="题目-31"><a class="markdownIt-Anchor" href="#题目-31"></a> 题目</h5>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>-50000 &lt;= nums[i] &lt;= 50000</code></li>
</ol>
<h5 id="思路-31"><a class="markdownIt-Anchor" href="#思路-31"></a> 思路</h5>
<p>各种排序~</p>
<h5 id="code-31"><a class="markdownIt-Anchor" href="#code-31"></a> code</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：Leetcode 2020-03月份每日一题</li>
        <li>本文作者：Xhofe</li>
        <li>创建时间：2020-03-01 17:20:18</li>
        <li>
            本文链接：https://nn.ci/posts/20-03-leetcode.html
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/leetcode/">#leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/posts/commonly-used-sort.html"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">常用排序算法</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/posts/ftmp-dev.html"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">FTmp开发记录</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
          
    <div class="waline-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/@waline/client"></script>
        <div id="wcomments"></div>
        <script data-pjax>
            function loadWaline() {
              Waline({
                el: '#wcomments',
                serverURL: 'https://waline.nn.ci',
                dark: 'body.dark-mode',
                uploadImage: false,
              });
              function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }
            }
            if ('true') {
                const loadWalineTimeout = setTimeout(() => {
                    loadWaline();
                    clearTimeout(loadWalineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadWaline);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2019</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Xhofe</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?dd18303f1d622e40a6fd71c2510b2bab";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10"><span class="nav-number">1.</span> <span class="nav-text"> 1-10</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">1.1.</span> <span class="nav-text"> 01 225. 用队列实现栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code"><span class="nav-number">1.1.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#02-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text"> 02 206. 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-2"><span class="nav-number">1.2.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#03-%E9%9D%A2%E8%AF%95%E9%A2%98-1001-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text"> 03 面试题 10.01. 合并排序的数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-3"><span class="nav-number">1.3.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#04-994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-number">1.4.</span> <span class="nav-text"> 04 994. 腐烂的橘子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="nav-number">1.4.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-4"><span class="nav-number">1.4.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#05-1103-%E5%88%86%E7%B3%96%E6%9E%9C-ii"><span class="nav-number">1.5.</span> <span class="nav-text"> 05 1103. 分糖果 II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-5"><span class="nav-number">1.5.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#06-%E9%9D%A2%E8%AF%95%E9%A2%9857-ii-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">1.6.</span> <span class="nav-text"> 06 面试题57 - II. 和为s的连续正数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-number">1.6.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="nav-number">1.6.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-6"><span class="nav-number">1.6.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#07-%E9%9D%A2%E8%AF%95%E9%A2%9859-ii-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">1.7.</span> <span class="nav-text"> 07 面试题59 - II. 队列的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-number">1.7.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="nav-number">1.7.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-7"><span class="nav-number">1.7.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#08-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">1.8.</span> <span class="nav-text"> 08 322. 零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-number">1.8.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="nav-number">1.8.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-8"><span class="nav-number">1.8.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#09-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">1.9.</span> <span class="nav-text"> 09 121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-number">1.9.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="nav-number">1.9.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-9"><span class="nav-number">1.9.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">1.10.</span> <span class="nav-text"> 10 543. 二叉树的直径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-number">1.10.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="nav-number">1.10.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-10"><span class="nav-number">1.10.3.</span> <span class="nav-text"> code</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-20"><span class="nav-number">2.</span> <span class="nav-text"> 11-20</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86"><span class="nav-number">2.1.</span> <span class="nav-text"> 11 1013. 将数组分成和相等的三个部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="nav-number">2.1.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="nav-number">2.1.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-11"><span class="nav-number">2.1.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="nav-number">2.2.</span> <span class="nav-text"> 12 1071. 字符串的最大公因子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="nav-number">2.2.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="nav-number">2.2.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-12"><span class="nav-number">2.2.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">2.3.</span> <span class="nav-text"> 13 169. 多数元素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="nav-number">2.3.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-13"><span class="nav-number">2.3.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">2.4.</span> <span class="nav-text"> 14 300. 最长上升子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="nav-number">2.4.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="nav-number">2.4.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-14"><span class="nav-number">2.4.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">2.5.</span> <span class="nav-text"> 15 695. 岛屿的最大面积</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="nav-number">2.5.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="nav-number">2.5.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-15"><span class="nav-number">2.5.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-%E9%9D%A2%E8%AF%95%E9%A2%98-0106-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="nav-number">2.6.</span> <span class="nav-text"> 16 面试题 01.06. 字符串压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-16"><span class="nav-number">2.6.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="nav-number">2.6.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-16"><span class="nav-number">2.6.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D"><span class="nav-number">2.7.</span> <span class="nav-text"> 17 1160. 拼写单词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-17"><span class="nav-number">2.7.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="nav-number">2.7.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-17"><span class="nav-number">2.7.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0"><span class="nav-number">2.8.</span> <span class="nav-text"> 18 836. 矩形重叠</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-18"><span class="nav-number">2.8.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="nav-number">2.8.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-18"><span class="nav-number">2.8.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">2.9.</span> <span class="nav-text"> 19 409. 最长回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-19"><span class="nav-number">2.9.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="nav-number">2.9.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-19"><span class="nav-number">2.9.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text"> 20 面试题40. 最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-20"><span class="nav-number">2.10.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="nav-number">2.10.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-20"><span class="nav-number">2.10.3.</span> <span class="nav-text"> code</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-31"><span class="nav-number">3.</span> <span class="nav-text"> 21-31</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text"> 21 365. 水壶问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-21"><span class="nav-number">3.1.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="nav-number">3.1.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-21"><span class="nav-number">3.1.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text"> 22 945. 使数组唯一的最小增量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-22"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-22"><span class="nav-number">3.2.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-number">3.3.</span> <span class="nav-text"> 23 876. 链表的中间结点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-23"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="nav-number">3.3.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-23"><span class="nav-number">3.3.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E9%9D%A2%E8%AF%95%E9%A2%98-1716-%E6%8C%89%E6%91%A9%E5%B8%88"><span class="nav-number">3.4.</span> <span class="nav-text"> 24 面试题 17.16. 按摩师</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-24"><span class="nav-number">3.4.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="nav-number">3.4.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-24"><span class="nav-number">3.4.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF"><span class="nav-number">3.5.</span> <span class="nav-text"> 25 892. 三维形体的表面积</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-25"><span class="nav-number">3.5.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="nav-number">3.5.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-25"><span class="nav-number">3.5.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-999-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%B8%80%E6%AD%A5%E6%8D%95%E8%8E%B7%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text"> 26 999. 可以被一步捕获的棋子数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-26"><span class="nav-number">3.6.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="nav-number">3.6.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-26"><span class="nav-number">3.6.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84"><span class="nav-number">3.7.</span> <span class="nav-text"> 27 914. 卡牌分组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-27"><span class="nav-number">3.7.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="nav-number">3.7.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-27"><span class="nav-number">3.7.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-820-%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81"><span class="nav-number">3.8.</span> <span class="nav-text"> 28 820. 单词的压缩编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-28"><span class="nav-number">3.8.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="nav-number">3.8.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-28"><span class="nav-number">3.8.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90"><span class="nav-number">3.9.</span> <span class="nav-text"> 29 1162. 地图分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-29"><span class="nav-number">3.9.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="nav-number">3.9.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-29"><span class="nav-number">3.9.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-%E9%9D%A2%E8%AF%95%E9%A2%9862-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">3.10.</span> <span class="nav-text"> 30 面试题62. 圆圈中最后剩下的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-30"><span class="nav-number">3.10.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="nav-number">3.10.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-30"><span class="nav-number">3.10.3.</span> <span class="nav-text"> code</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">3.11.</span> <span class="nav-text"> 31 912. 排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-31"><span class="nav-number">3.11.1.</span> <span class="nav-text"> 题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="nav-number">3.11.2.</span> <span class="nav-text"> 思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-31"><span class="nav-number">3.11.3.</span> <span class="nav-text"> code</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
